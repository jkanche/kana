/* Creates the cache for a given step.
 *
 * `cache` is expected to be an object where the steps are the keys; each entry
 * is itself another object that contains the cached results for that step.
 * This function will create a closure that includes the input `cache` so that
 * each step just needs to supply the key directly to obtain the step-specific
 * cache object. If the step's cache already exists, it is directly returned.
 */
function createInitCache(cache) {
  return function(key) {
    if (! (key in cache)) {
      cache[key] = {};
    }
    return cache[key];
  };
}

/* 
 * Free a cached Wasm-constructed object.
 *
 * Free a cached object by calling its `delete()` method and replacing it with
 * a `null` object in the cache. `cache` should be a step-specific cache,
 * usually generated by calling the function returned by `createInitCache()`.
 */
function freeCache(cache, key) {
  if (cache[key] !== undefined && cache[key] !== null) {
    cache[key].delete();
    cache[key] = null;
  }
  return;
}

/*
 * Decide whether to run a step.
 *
 * This will decide whether a step should be (re-)run based on whether its
 * parameters have changed or upstream steps have been rerun. 
 *
 * `parameters` is expected to an object storing the previous parameters.
 * `upstream` is expected to be a set containing the upstream status that have
 * been re-run. Both of these objects are captured in a closure so that callers
 * do not have to constantly supply them.
 *
 * `step` is the name of the current step. `latest` is an object containing the
 * latest parameters; this is compared to existing values (if any) in
 * `parameters`.  `depends` is an array of the names of the upstream steps,
 * which is checked against `upstream`. `body` is the function to be executed
 * if a rerun is desired.
 *
 * The return value of `body` should be an object as an extra `$step` property is
 * added with the name of the step for convenience. 
 */ 
function createRunStep(parameters, upstream) {
  return function(step, latest, depends, body) {
    var previous = parameters[step];
    var changed = true;
    var upchanged = false;

    for (const x of depends) {
      if (upstream.has(x)) {
        upchanged = true;
        break;
      }
    }

    if (!upchanged) {
      if (previous !== undefined) {
        if (JSON.stringify(previous) == JSON.stringify(latest)) {
          changed = false;
        }
      }
    }
  
    if (!changed) {
      return null;
    } else {
      var output = body();
      output["$step"] = step;
      parameters[step] = latest;
      upstream.add(step);
      return output;
    }
  };
}

/* Process the output of a step.
 *
 * Given a step to run in `body`, this function will post a message back to the
 * main thread with a success status and the time taken to execute the step.
 */
function processOutput(body, args) {
  var t0 = performance.now();

  var output = null;
  try {
    var output = body(args);
  } catch (error) {
    console.log(error);
    throw error;
  }

  if (output !== null) {
    var t1 = performance.now();
    var ftime = (t1 - t0) / 1000;
    postMessage({
        type: `${output["$step"]}_DONE`,
        resp: `~${ftime.toFixed(2)} sec`,
        msg: 'Done'
    });
  }

  return output;
}

/* Allocate a cached buffer on the Wasm heap.
 *
 * Creates a `WasmBuffer` in the cache if one does not already exist with the
 * desired size and type. This avoids unnecessary reallocations if an
 * appropriate buffer was already created from a previous run.
 */
function allocateBuffer(wasm, size, type, cache, name = "buffer") {
  var reallocate = true;
  if (name in cache) {
    var candidate = cache[name];
    if (candidate.size != size || candidate.type != type) {
      candidate.free();
    } else {
      reallocate = false;
    }
  }

  if (reallocate) {
    cache[name] = new WasmBuffer(wasm, size, type);
  }
  return cache[name];
}
